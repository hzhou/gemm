include: common.def
include: matrix.def
include: simple.def

macros:
    N: 10000

page: test
    module: c
    use_double: 1
    CC: gcc -std=c99 -O2 -mavx2 -g
    # CC: icc -std=c99 -O3

    $(if:0)
        $call create_random
    $(elif:0)
        $call run_check, 8
    $(else)
        $call run_test, 1000

subcode: mult_2_common
    $sumcode(M*M) C[i]=0.0

    $include <immintrin.h>
    $local p_A, p_B, p_C: double *
    $(for:A,B,C)
        p$1 = $1
    DUMP_STUB mult_2_init

subcode: mult_2
    $call @mult_2_common
    # C[i,j] += A[i,k] * B[k,j]
    $for i=0:M:4
        pA = A + i * M
        $for k=0:M:4
            pB = B + k * M
            pC = C + i * M
            $for j=0:M:4
                $call mult_4x4
                pB += 4
                pC += 4
            pA += 4

    subcode: mult_4x4
        $call ver2

    # --------------
    macros:
        v0: 3*M+3, 2*M+2, M+1, 0
        v1: 2*M+3, M+2, 1, 3*M+0
        v2: M+3, 2, 3*M+1, 2*M+0
        v3: 3, 3*M+2, 2*M+1, M+0
        c3210: 0xe4  # identity
        c2103: 0x93  # rotate 1
    subcode: ver2
        $local b0,b1,b2,b3: __m256d
        $local v: __m256i
        $(for:0-3)
            v = _mm256_set_epi64x($(v$1))
            b$1 = _mm256_i64gather_pd(pB, v, 8)

        $local a, a2: __m256d
        $(for:i in 0-3)
            a  = _mm256_load_pd(pA)
            a2 = _mm256_load_pd(pC)
            $(for:j in 0-3)
                a2 = _mm256_add_pd(a2, _mm256_mul_pd(a, b$(j)))
                $(if:j<3)
                    a  = _mm256_permute4x64_pd(a, $(c2103))
            _mm256_store_pd(pC, a2)
            $(for:A,C)
                $(if:i<3)
                    p$1+=M
                $(else)
                    p$1-=M*3
    # --------------
    subcode: ver1
        $call load_4_b

        $(for:i in 0-3)
            $local a: __m256d
            a = _mm256_load_pd(pA)
            $(for:j in 0-3)
                $local a2: __m256d
                a2 = _mm256_mul_pd(a, b$(j))
                $call sum_a, a2, (pC+$(j))
            $call adjust_pA_pC, $(i)

        subcode: adjust_pA_pC(i)
            $(if:i<3)
                pA+=M
                pC+=M
            $(else)
                pA-=M*3
                pC-=M*3

    subcode: load_4_b
        $local b0,b1,b2,b3: __m256d
        $(block:mult_2_init)
            $local v1: __m256i
            v1 = _mm256_set_epi64x(3*M, 2*M, M, 0)
        $(for:0-3)
            b$1 = _mm256_i64gather_pd(pB+$1, v1, 8)

    subcode: sum_a(a, C)
        $(if:1)
            $local lo, hi, h2: __m128d
            lo = _mm256_castpd256_pd128($(a));
            hi = _mm256_extractf128_pd($(a), 1);
            lo = _mm_add_pd(lo, hi);
            h2 = _mm_unpackhi_pd(lo, lo);
            h2 = _mm_add_sd(h2, lo);
            *$(C) += _mm_cvtsd_f64(h2)
        $(else)
            *$(C) = _mm256_cvtsd_f64($(a))

subcode: mult_2_c
    $call mult_2_common

    $local a1, a2: __m256d
    $for i=0:M
        pB = B
        $for j=0:M:4
            a1 = _mm256_load_pd(pA)
            $for jj=0:4
                a2 = _mm256_set1_pd(0.0)
                $call add_a1_B_to_a2
                $call sum_a2, pC
                pB++
                pC++
            pA+=4

    subcode: sum_a2(C)
        $(if:0)
            __m128d lo = _mm256_castpd256_pd128(a2);
            __m128d hi = _mm256_extractf128_pd(a2, 1);
            lo = _mm_add_pd(lo, hi);
            __m128d h2 = _mm_unpackhi_pd(lo, lo);
            h2 = _mm_add_sd(h2, lo);
            _mm_store_sd($(C), h2)
        $(else)
            *$(C) = _mm256_cvtsd_f64(a2)

    subcode: add_a1_B_to_a2
        $(block:mult_2_init)
            $local b1: __m256d
            $local v1, v2: __m256i
            v2 = _mm256_set1_epi64x(4*M)
        v1 = _mm256_set_epi64x(3*M, 2*M, M, 0)
        $for k=0:M:4
            b1 = _mm256_i64gather_pd(pB, v1, 8)
            a2 = _mm256_add_pd(a2, _mm256_mul_pd(a1, b1))
            v1 = _mm256_add_epi64(v1, v2)

subcode: mult_3
    $call mult_blas
